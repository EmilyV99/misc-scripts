//start Misc Functions
int dirX(int dir)
{
    switch(dir)
    {
        case DIR_RIGHT: case DIR_RIGHTUP: case DIR_RIGHTDOWN:
            return 1;
        case DIR_LEFT: case DIR_LEFTUP: case DIR_LEFTDOWN:
            return -1;
        default:
            return 0;
    }
}

int dirY(int dir)
{
    switch(dir)
    {
        case DIR_DOWN: case DIR_LEFTDOWN: case DIR_RIGHTDOWN:
            return 1;
        case DIR_UP: case DIR_LEFTUP: case DIR_RIGHTUP:
            return -1;
        default:
            return 0;
    }
}

int remX(int dir)
{
	switch(dir)
	{
		case DIR_UP: case DIR_LEFTUP: case DIR_RIGHTUP:
			return DIR_UP;
		case DIR_DOWN: case DIR_LEFTDOWN: case DIR_RIGHTDOWN:
			return DIR_DOWN;
		default:
			return -1;
	}
}

int remY(int dir)
{
	switch(dir)
	{
		case DIR_LEFT: case DIR_LEFTUP: case DIR_LEFTDOWN:
			return DIR_LEFT;
		case DIR_RIGHT: case DIR_RIGHTUP: case DIR_RIGHTDOWN:
			return DIR_RIGHT;
		default:
			return -1;
	}
}

int R_SpinDir8(int dir)
{
	R_SpinDir8(dir, 1);
}

int R_SpinDir8(int dir, int count)
{
	if(count<0)
	{
		for(int q = -count; q > 0; --q)
			switch(dir)
			{
				case DIR_UP: return DIR_LEFTUP;
				case DIR_RIGHTUP: return DIR_UP;
				case DIR_RIGHT: return DIR_RIGHTUP;
				case DIR_RIGHTDOWN: return DIR_RIGHT;
				case DIR_DOWN: return DIR_RIGHTDOWN;
				case DIR_LEFTDOWN: return DIR_DOWN;
				case DIR_LEFT: return DIR_LEFTDOWN;
				case DIR_LEFTUP: return DIR_LEFT;
				default: return -1;
			}
	}
	else
	{
		for(;count > 0; --count)
			switch(dir)
			{
				case DIR_UP: return DIR_RIGHTUP;
				case DIR_RIGHTUP: return DIR_RIGHT;
				case DIR_RIGHT: return DIR_RIGHTDOWN;
				case DIR_RIGHTDOWN: return DIR_DOWN;
				case DIR_DOWN: return DIR_LEFTDOWN;
				case DIR_LEFTDOWN: return DIR_LEFT;
				case DIR_LEFT: return DIR_LEFTUP;
				case DIR_LEFTUP: return DIR_UP;
				default: return -1;
			}
	}
}
//end Misc Functions
//start CanWalkM
//lweapon
bool CanWalkM(lweapon weap, mapdata map, int dir, int step)
{
	return CanWalkM(weap, map, dir, step, false);
}

bool CanWalkM(lweapon weap, mapdata map, int dir, int step, bool useHit)
{
	if(!weap->isValid())return false;
	return CanWalkM(weap->X, weap->Y, weap->X + Cond(useHit, weap->HitWidth, weap->TileWidth * 16) - 1, weap->Y + Cond(useHit, weap->HitHeight, weap->TileHeight * 16) - 1, map, dir, step);
}
//eweapon
bool CanWalkM(eweapon weap, mapdata map, int dir, int step)
{
	return CanWalkM(weap, map, dir, step, false);
}

bool CanWalkM(eweapon weap, mapdata map, int dir, int step, bool useHit)
{
	if(!weap->isValid())return false;
	return CanWalkM(weap->X, weap->Y, weap->X + Cond(useHit, weap->HitWidth, weap->TileWidth * 16) - 1, weap->Y + Cond(useHit, weap->HitHeight, weap->TileHeight * 16) - 1, map, dir, step);
}
//npc
bool CanWalkM(npc n, mapdata map, int dir, int step)
{
	return CanWalkM(n, map, dir, step, false);
}

bool CanWalkM(npc n, mapdata map, int dir, int step, bool useHit)
{
	if(!n->isValid())return false;
	return CanWalkM(n->X, n->Y, n->X + Cond(useHit, n->HitWidth, n->TileWidth * 16) - 1, n->Y + Cond(useHit, n->HitHeight, n->TileHeight * 16) - 1, map, dir, step);
}
//ffc
bool CanWalkM(ffc f, mapdata map, int dir, int step)
{
	return CanWalkM(f, map, dir, step, false);
}

bool CanWalkM(ffc f, mapdata map, int dir, int step, bool useEffect)
{
	return CanWalkM(f->X, f->Y, f->X + Cond(useEffect, f->EffectWidth, f->TileWidth * 16) - 1, f->Y + Cond(useEffect, f->EffectHeight, f->TileHeight * 16) - 1, map, dir, step);
}
//Link
bool CanWalkM(mapdata map, int dir, int step, bool largeHitbox)
{
	return CanWalkM(Link->X, Link->Y + Cond(largeHitbox, 0, 8), Link->X + 15, Link->Y + 15, map, dir, step);
}
//Main
bool CanWalkM(int x, int y, int xx, int yy, mapdata map, int dir, int step)
{
	int width = xx - x + 1;
	int height = yy - y + 1;
    switch(dir)
	{
		case DIR_UP: return !(y-step<0||map->isSolid(x,y-step)||map->isSolid(x+Floor(width/2),y-step)||map->isSolid(xx,y-step));
		case DIR_DOWN: return !(yy+step>=176||map->isSolid(x,yy+step)||map->isSolid(x+Floor(width/2),yy+step)||map->isSolid(xx,yy+step));
		case DIR_LEFT: return !(x-step<0||map->isSolid(x-step,y)||map->isSolid(x-step,y+Floor(height/2))||map->isSolid(x-step,yy));
		case DIR_RIGHT: return !(xx+step>=256||map->isSolid(xx+step,y)||map->isSolid(xx+step,y+Floor(height/2))||map->isSolid(xx+step,yy));
		case DIR_LEFTUP: return (CanWalkM(x, y, xx, yy, map, DIR_LEFT, step) && CanWalkM(x, y, xx, yy, map, DIR_UP, step));
		case DIR_LEFTDOWN: return (CanWalkM(x, y, xx, yy, map, DIR_LEFT, step) && CanWalkM(x, y, xx, yy, map, DIR_DOWN, step));
		case DIR_RIGHTUP: return (CanWalkM(x, y, xx, yy, map, DIR_RIGHT, step) && CanWalkM(x, y, xx, yy, map, DIR_UP, step));
		case DIR_RIGHTDOWN: return (CanWalkM(x, y, xx, yy, map, DIR_RIGHT, step) && CanWalkM(x, y, xx, yy, map, DIR_DOWN, step));
	}
	return false; //invalid direction
}
//end CanWalkM

mapdata CurMapdata()
{
	return Game->LoadMapData(Game->GetCurMap(), Game->GetCurScreen());
}

void MooshDrawTile(int layer, int cx, int cy, int tile, int blockw, int blockh, int cset, int xscale, int yscale, int rx, int ry, int rangle, int flip, bool transparency, int opacity){
    int w = xscale;
    if(xscale==-1)
        w = blockw*16;
    int h = yscale;
    if(yscale==-1)
        h = blockh*16;
    Screen->DrawTile(layer, cx-w/2, cy-h/2, tile, blockw, blockh, cset, xscale, yscale, rx-w/2, ry-h/2, rangle, flip, transparency, opacity);
}
